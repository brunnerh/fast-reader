<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Fast Reader</title>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link
			href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=DM+Sans:wght@400;500;700&display=swap"
			rel="stylesheet"
		>
		<style>
			:root {
				color-scheme: dark;

				--bg-primary: #0a0e14;
				--bg-secondary: #151b26;
				--bg-tertiary: #1a2332;
				--text-primary: #e6edf3;
				--text-secondary: #8b95a5;
				--border-color: #2d3748;
				--highlight-color: #fbbf24;
				--accent-primary: #06d6a0;
				--accent-secondary: #00b4d8;
				--button-bg: #1e2936;
				--button-hover: #2d3e50;
				--button-text: #e6edf3;
				--slider-track: #1e2936;
				--slider-thumb: #06d6a0;
				--slider-thumb-hover: #05c28f;
				--shadow: rgba(0, 0, 0, 0.4);
				--glow: rgba(6, 214, 160, 0.3);
			}

			@media (prefers-color-scheme: light) {
				:root {
					color-scheme: light;

					--bg-primary: #f8fafc;
					--bg-secondary: #ffffff;
					--bg-tertiary: #f1f5f9;
					--text-primary: #0f172a;
					--text-secondary: #64748b;
					--border-color: #e2e8f0;
					--highlight-color: #f59e0b;
					--accent-primary: #06d6a0;
					--accent-secondary: #0284c7;
					--button-bg: #f1f5f9;
					--button-hover: #e2e8f0;
					--button-text: #0f172a;
					--slider-track: #e2e8f0;
					--slider-thumb: #06d6a0;
					--slider-thumb-hover: #05c28f;
					--shadow: rgba(0, 0, 0, 0.1);
					--glow: rgba(6, 214, 160, 0.2);
				}
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}

			@keyframes fadeInUp {
				from {
					opacity: 0;
					transform: translateY(20px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}

			@keyframes glow {
				0%, 100% {
					box-shadow:
						0 0 20px var(--glow),
						0 4px 30px var(--shadow);
				}
				50% {
					box-shadow:
						0 0 30px var(--glow),
						0 4px 30px var(--shadow);
				}
			}

			body {
				font-family:
					'DM Sans', -apple-system, BlinkMacSystemFont,
					'Segoe UI', sans-serif;
				background: linear-gradient(
					135deg,
					var(--bg-primary) 0%,
					var(--bg-secondary) 100%
				);
				color: var(--text-primary);
				height: 100vh;
				display: flex;
				flex-direction: column;
				position: relative;
				overflow: hidden;
			}

			body::before {
				content: '';
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background-image:
					radial-gradient(
						circle at 20% 80%,
						rgba(6, 214, 160, 0.05) 0%,
						transparent 50%
					),
					radial-gradient(
					circle at 80% 20%,
					rgba(0, 180, 216, 0.05) 0%,
					transparent 50%
				);
				pointer-events: none;
				z-index: 0;
			}

			.container {
				display: flex;
				flex-direction: column;
				height: 100%;
				position: relative;
				z-index: 2;
				animation: fadeInUp 0.8s ease-out;
			}

			@media (min-width: 1000px) {
				.container {
					flex-direction: row;
				}
			}

			.panel {
				padding: 24px;
				overflow: auto;
				backdrop-filter: blur(10px);
			}

			.left-panel {
				flex: 1;
				border-right: 2px solid var(--border-color);
				display: flex;
				flex-direction: column;
				overflow: hidden;
				background: linear-gradient(
					180deg,
					var(--bg-secondary) 0%,
					var(--bg-tertiary) 100%
				);
				animation: fadeInUp 0.8s ease-out 0.1s both;
			}

			@media (min-width: 1000px) {
				.left-panel {
					flex: 1;
				}
			}

			.right-panel {
				flex: 1;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				background: var(--bg-primary);
				animation: fadeInUp 0.8s ease-out 0.2s both;
			}

			@media (min-width: 1000px) {
				.right-panel {
					flex: 1;
				}
			}

			.panel-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 20px;
				padding-bottom: 16px;
				border-bottom: 2px solid var(--border-color);
			}

			.panel-title {
				font-size: 1.25em;
				font-weight: 700;
				letter-spacing: 0.5px;
				text-transform: uppercase;
				color: var(--accent-primary);
				position: relative;
				padding-left: 12px;
			}

			.panel-title::before {
				content: '';
				position: absolute;
				left: 0;
				top: 50%;
				transform: translateY(-50%);
				width: 4px;
				height: 100%;
				background: linear-gradient(
					180deg,
					var(--accent-primary),
					var(--accent-secondary)
				);
				border-radius: 2px;
			}

			.btn {
				padding: 10px 20px;
				background: var(--button-bg);
				color: var(--button-text);
				border: 1px solid var(--border-color);
				border-radius: 6px;
				cursor: pointer;
				font-size: 14px;
				font-weight: 500;
				font-family: 'DM Sans', sans-serif;
				transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
				position: relative;
				overflow: hidden;
			}

			.btn::before {
				content: '';
				position: absolute;
				top: 50%;
				left: 50%;
				width: 0;
				height: 0;
				border-radius: 50%;
				background: rgba(255, 255, 255, 0.1);
				transform: translate(-50%, -50%);
				transition: width 0.6s, height 0.6s;
			}

			.btn:hover::before {
				width: 300px;
				height: 300px;
			}

			.btn:hover {
				background: var(--button-hover);
				transform: translateY(-1px);
				box-shadow: 0 4px 12px var(--shadow);
			}

			.btn:active {
				transform: translateY(0);
			}

			.btn:disabled {
				opacity: 0.4;
				cursor: not-allowed;
				transform: none;
			}

			.btn:disabled:hover {
				background: var(--button-bg);
				box-shadow: none;
			}

			.btn-primary {
				background: linear-gradient(
					135deg,
					var(--accent-primary) 0%,
					var(--accent-secondary) 100%
				);
				color: #0a0e14;
				border: none;
				font-weight: 600;
				box-shadow: 0 0 20px var(--glow);
			}

			.btn-primary:hover {
				background: linear-gradient(
					135deg,
					var(--accent-secondary) 0%,
					var(--accent-primary) 100%
				);
				box-shadow: 0 0 30px var(--glow), 0 4px 16px var(--shadow);
			}

			.btn-large {
				padding: 14px 32px;
				font-size: 15px;
				font-weight: 600;
				box-sizing: content-box;
				min-width: 6ch;
				text-align: center;
			}

			#text-input {
				width: 100%;
				flex: 1;
				padding: 20px;
				font-size: 16px;
				font-family: 'DM Sans', sans-serif;
				line-height: 1.6;
				border: 2px solid var(--border-color);
				border-radius: 8px;
				resize: none;
				background: var(--bg-tertiary);
				color: var(--text-primary);
				transition: all 0.3s ease;
			}

			#text-input:focus {
				outline: none;
				border-color: var(--accent-primary);
				box-shadow: 0 0 0 3px var(--glow);
			}

			#text-display {
				width: 100%;
				flex: 1;
				padding: 20px;
				font-size: 16px;
				font-family: 'DM Sans', sans-serif;
				border: 2px solid var(--border-color);
				border-radius: 8px;
				background: var(--bg-tertiary);
				color: var(--text-secondary);
				line-height: 1.8;
				white-space: pre-wrap;
				word-wrap: break-word;
				overflow-y: auto;
			}

			#text-display .word {
				cursor: pointer;
				padding: 3px 4px;
				border-radius: 4px;
				transition: all 0.2s ease;
			}

			#text-display .word:hover {
				background: var(--button-bg);
				color: var(--text-primary);
			}

			#text-display .word.current {
				color: var(--highlight-color);
				background: rgba(251, 191, 36, 0.1);
			}

			.word-display {
				width: 100%;
				max-width: 600px;
				min-height: 2cap;
				height: 240px;
				display: flex;
				align-items: center;
				justify-content: center;
				border: none;
				border-radius: 16px;
				margin-bottom: 40px;
				background: linear-gradient(
					135deg,
					var(--bg-secondary) 0%,
					var(--bg-tertiary) 100%
				);
				font-size: 32px;
				font-weight: 700;
				font-family: 'JetBrains Mono', monospace;
				position: relative;
				box-shadow:
					0 10px 40px var(--shadow),
					inset 0 1px 0 rgba(255, 255, 255, 0.1);
				overflow: hidden;
			}

			.word-display::before {
				content: '';
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				border-radius: 16px;
				padding: 2px;
				background: linear-gradient(
					135deg,
					var(--accent-primary),
					var(--accent-secondary)
				);
				-webkit-mask:
					linear-gradient(#fff 0 0) content-box,
					linear-gradient(#fff 0 0);
				-webkit-mask-composite: xor;
				mask-composite: exclude;
				opacity: 0.5;
			}

			.word-display.playing {
				animation: glow 2s ease-in-out infinite;
			}

			#word-display-text {
				display: flex;
				position: relative;
				z-index: 1;
			}

			.controls {
				width: 100%;
				max-width: 600px;
				display: flex;
				flex-direction: column;
				gap: 24px;
			}

			.media-controls {
				display: flex;
				justify-content: center;
				gap: 16px;
			}

			.wpm-controls {
				display: flex;
				align-items: center;
				gap: 16px;
				padding: 16px;
				background: var(--bg-secondary);
				border-radius: 8px;
				border: 1px solid var(--border-color);
			}

			.wpm-input {
				width: 90px;
				padding: 10px;
				font-size: 15px;
				font-weight: 600;
				font-family: 'JetBrains Mono', monospace;
				text-align: center;
				border: 2px solid var(--border-color);
				border-radius: 6px;
				background: var(--bg-tertiary);
				color: var(--accent-primary);
				transition: all 0.3s ease;
			}

			.wpm-input:focus {
				outline: none;
				border-color: var(--accent-primary);
				box-shadow: 0 0 0 3px var(--glow);
			}

			.slider-container {
				display: flex;
				flex-direction: column;
				gap: 10px;
			}

			.slider-label {
				font-size: 13px;
				font-weight: 600;
				text-transform: uppercase;
				letter-spacing: 0.5px;
				color: var(--text-secondary);
			}

			.progress-slider-container {
				margin-top: 8px;
				padding: 16px;
				background: var(--bg-secondary);
				border-radius: 8px;
				border: 1px solid var(--border-color);
			}

			.progress-slider {
				width: 100%;
				height: 8px;
				-webkit-appearance: none;
				appearance: none;
				background: var(--slider-track);
				border-radius: 4px;
				outline: none;
				cursor: pointer;
				position: relative;
			}

			.progress-slider::-webkit-slider-thumb {
				-webkit-appearance: none;
				appearance: none;
				width: 18px;
				height: 18px;
				background: linear-gradient(
					135deg,
					var(--accent-primary),
					var(--accent-secondary)
				);
				border-radius: 50%;
				cursor: pointer;
				transition: all 0.3s ease;
				box-shadow: 0 2px 8px var(--glow);
			}

			.progress-slider::-webkit-slider-thumb:hover {
				transform: scale(1.2);
				box-shadow: 0 4px 16px var(--glow);
			}

			.progress-slider::-moz-range-thumb {
				width: 18px;
				height: 18px;
				background: linear-gradient(
					135deg,
					var(--accent-primary),
					var(--accent-secondary)
				);
				border-radius: 50%;
				cursor: pointer;
				border: none;
				transition: all 0.3s ease;
				box-shadow: 0 2px 8px var(--glow);
			}

			.progress-slider::-moz-range-thumb:hover {
				transform: scale(1.2);
				box-shadow: 0 4px 16px var(--glow);
			}

			.hidden {
				display: none !important;
			}

			fieldset {
				border: none;
				padding: 0;
				margin: 0;
			}

			fieldset:disabled {
				opacity: 0.5;
				pointer-events: none;
			}

			#paste-btn {
				display: none;
			}

			@media (max-width: 999px) and (max-height: 600px) {
				#text-input,
				#text-display,
				#toggle-mode-btn {
					display: none !important;
				}

				#paste-btn {
					display: block;
				}

				.left-panel {
					flex: 0 0 auto;
					overflow: visible;
				}

				.panel-header {
					margin-bottom: 0;
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<form id="input-form" class="left-panel panel">
				<div class="panel-header">
					<h1 class="panel-title">Text</h1>
					<button
						id="toggle-mode-btn"
						class="btn btn-large"
						type="submit"
					>
						Start
					</button>
					<button
						id="paste-btn"
						class="btn btn-primary btn-large"
						type="button"
					>
						Paste
					</button>
				</div>
				<textarea
					id="text-input"
					placeholder="Enter or paste your text here..."
					required
				></textarea>
				<div id="text-display" class="hidden"></div>
			</form>
			<div class="right-panel panel">
				<div id="word-display" class="word-display">
					<span id="word-display-text" class="anchor">Ready</span>
				</div>
				<fieldset id="playback-fieldset" class="controls" disabled>
					<div class="media-controls">
						<button
							id="play-pause-btn"
							class="btn btn-primary btn-large"
						>
							Play
						</button>
						<button id="reset-btn" class="btn btn-large">
							Reset
						</button>
					</div>
					<div class="wpm-controls">
						<label class="slider-label">WPM:</label>
						<input
							type="number"
							id="wpm-input"
							class="wpm-input"
							value="200"
						>
						<input
							type="range"
							id="wpm-slider"
							class="progress-slider"
							value="200"
							min="100"
							max="1000"
							style="flex: 1"
						>
					</div>
					<div class="slider-container progress-slider-container">
						<label class="slider-label" id="progress-label">
							Progress: 0 / 0
						</label>
						<input
							type="range"
							id="progress-slider"
							class="progress-slider"
							value="0"
							min="0"
							max="100"
							step="1"
						>
					</div>
				</fieldset>
			</div>
		</div>

		<script>
			// @ts-check
			/// <reference lib="dom" />
			/// <reference lib="esnext" />

			/**
			 * @param {string} id
			 * @returns {HTMLElement}
			 */
			function get(id) {
				const element = document.getElementById(id);
				if (!element) {
					throw new Error(
						`Element with ID "${id}" not found.`,
					);
				}

				return element;
			}

			const textInput =
				/** @type {HTMLTextAreaElement} */ (get(
					'text-input',
				));
			const textDisplay = get('text-display');
			const inputForm =
				/** @type {HTMLFormElement} */ (get(
					'input-form',
				));
			const toggleModeBtn = get('toggle-mode-btn');
			const pasteBtn =
				/** @type {HTMLButtonElement} */ (get(
					'paste-btn',
				));
			const wordDisplay = get('word-display');
			const wordDisplayText = get('word-display-text');
			const playPauseBtn =
				/** @type {HTMLButtonElement} */ (get(
					'play-pause-btn',
				));
			const resetBtn =
				/** @type {HTMLButtonElement} */ (get(
					'reset-btn',
				));
			const wpmInput =
				/** @type {HTMLInputElement} */ (get(
					'wpm-input',
				));
			const wpmSlider =
				/** @type {HTMLInputElement} */ (get(
					'wpm-slider',
				));
			const progressSlider =
				/** @type {HTMLInputElement} */ (get(
					'progress-slider',
				));
			const progressLabel = get('progress-label');
			const playbackFieldset =
				/** @type {HTMLFieldSetElement} */ (get(
					'playback-fieldset',
				));

			let text = '';
			/** @type {'edit' | 'view'} */
			let mode = 'edit';
			/** @type {(
			  { type: 'whitespace', text: string } |
			  { type: 'word', text: string, wordIndex: number, partIndex: number, displayText?: string }
			)[]} */
			let tokens = [];
			/** @type {{ type: 'word', text: string, wordIndex: number, partIndex: number, displayText?: string }[]} */
			let wordTokens = [];
			let currentIndex = 0;
			let isPlaying = false;
			/** @type {number | undefined} */
			let playInterval = undefined;
			let wpm = 200;
			const wordLengthCutoff = 20;

			/**
			 * @param {string} text
			 * @returns {number}
			 */
			function getWordTime(text) {
				const baseInterval = 60_000 / wpm;
				let multiplier = 1;
				const trimmed = text.trim();
				const length = trimmed.length;
				if (length > 10) {
					multiplier += Math.min(
						(length - 10) / (wordLengthCutoff - 10),
						1,
					);
				}

				if (trimmed.endsWith('.'))
					multiplier += 1;
				else if (
					trimmed.endsWith(',') ||
					trimmed.endsWith(';')
				) {
					multiplier += 0.5;
				}

				return baseInterval * multiplier;
			}

			/**
			 * Breaks a long word into chunks by character count
			 * @param {string} word - The word to break
			 * @param {number} maxLength - Maximum length per chunk
			 * @param {number} wordIndex - The word index for tracking
			 * @returns {Array<{type: 'word', text: string, wordIndex: number, partIndex: number, displayText?: string}>}
			 */
			function breakLongWord(word, maxLength, wordIndex) {
				const chunks = [];

				// Break by hard character count
				for (
					let i = 0;
					i < word.length;
					i += maxLength
				) {
					const chunk = word.slice(i, i + maxLength);
					const isLast = i + maxLength >= word.length;
					chunks.push({
						type: /** @type {const} */ ('word'),
						text: chunk,
						wordIndex: wordIndex,
						partIndex: i / maxLength,
						displayText: isLast
							? chunk
							: chunk + '-',
					});
				}

				return chunks;
			}

			/**
			 * Helper function to emit a word token, handling slash-splitting and long words
			 * @param {string} wordText
			 * @param {number} wordIndex
			 * @param {Array<{type: 'word' | 'whitespace', text: string, wordIndex?: number, partIndex?: number, displayText?: string}>} tokens
			 * @returns {number} Updated word index
			 */
			function emitWordToken(
				wordText,
				wordIndex,
				tokens,
			) {
				const slashParts = wordText.split('/');

				if (slashParts.length > 1) {
					for (
						let k = 0;
						k < slashParts.length;
						k++
					) {
						const part = slashParts[k];
						if (part.length === 0)
							continue;

						const partWithSlash =
							k < slashParts.length - 1
								? part + '/'
								: part;

						if (partWithSlash.length > 20) {
							const chunks = breakLongWord(
								partWithSlash,
								20,
								wordIndex,
							);
							tokens.push(...chunks);
						}
						else {
							tokens.push({
								type:
									/** @type {const} */ ('word'),
								text: partWithSlash,
								wordIndex: wordIndex,
								partIndex: 0,
							});
						}
						wordIndex++;
					}
				}
				else {
					if (wordText.length > 20) {
						const chunks = breakLongWord(
							wordText,
							20,
							wordIndex,
						);
						tokens.push(...chunks);
					}
					else {
						tokens.push({
							type: /** @type {const} */ ('word'),
							text: wordText,
							wordIndex: wordIndex,
							partIndex: 0,
						});
					}
					wordIndex++;
				}

				return wordIndex;
			}

			/**
			 * @param {string} text
			 */
			function tokenizeText(text) {
				const tokens = [];
				let wordIndex = 0;

				const segmenter = new Intl.Segmenter(
					undefined,
					{
						granularity: 'word',
					},
				);
				const segments = Array.from(
					segmenter.segment(text),
				);

				let pendingLeadingChars = '';

				for (let i = 0; i < segments.length; i++) {
					const segment = segments[i];

					if (segment.isWordLike) {
						// Start with any pending leading characters
						let wordText = pendingLeadingChars +
							segment.segment;
						pendingLeadingChars = '';

						// Look ahead to collect trailing non-word characters (punctuation, etc.)
						// Stop when we hit whitespace or another word-like segment
						for (
							let j = i + 1;
							j < segments.length;
							j++
						) {
							const nextSeg = segments[j];
							if (!nextSeg.isWordLike) {
								const trimmed = nextSeg.segment
									.trim();
								if (trimmed.length > 0) {
									// Non-whitespace punctuation - attach it
									wordText += nextSeg.segment;
									i = j; // Skip this segment in main loop
								}
								else {
									// Whitespace - stop looking ahead
									break;
								}
							}
							else {
								// Another word - stop looking ahead
								break;
							}
						}

						// Emit the word token
						wordIndex = emitWordToken(
							wordText,
							wordIndex,
							tokens,
						);
					}
					else {
						// Non-word segment
						const trimmed = segment.segment.trim();
						if (trimmed.length > 0) {
							// Non-whitespace character - accumulate as leading for next word
							pendingLeadingChars += segment
								.segment;
						}
						else {
							// Whitespace
							// If we have pending leading chars, emit them as a standalone word token
							if (pendingLeadingChars) {
								wordIndex = emitWordToken(
									pendingLeadingChars,
									wordIndex,
									tokens,
								);
								pendingLeadingChars = '';
							}
							// Emit the whitespace
							tokens.push({
								type:
									/** @type {const} */ ('whitespace'),
								text: segment.segment,
							});
						}
					}
				}

				// Handle any remaining pending leading chars (e.g., text ends with punctuation)
				if (pendingLeadingChars) {
					emitWordToken(
						pendingLeadingChars,
						wordIndex,
						tokens,
					);
				}

				return tokens;
			}

			function positionLetters() {
				/** @type {NodeListOf<HTMLElement>} */
				const letters = wordDisplayText
					.querySelectorAll('.letter');
				if (letters.length === 0)
					return;

				const anchorIndex = Array.from(letters)
					.findIndex((l) =>
						l.classList.contains('anchor-letter')
					);
				if (anchorIndex === -1)
					return;

				const anchorLetter = letters[anchorIndex];

				const anchorRect = anchorLetter
					.getBoundingClientRect();
				const anchorCenterX = anchorRect.left +
					anchorRect.width / 2;
				const boxRect = wordDisplay
					.getBoundingClientRect();
				const boxCenterX = boxRect.left +
					boxRect.width / 2;

				const offsetX = boxCenterX - anchorCenterX;
				letters.forEach((l) =>
					l.style.transform =
						`translateX(${offsetX}px)`
				);
			}

			/**
			 * @param {string} word
			 */
			function getAnchorWord(word) {
				if (!word || word.length === 0)
					return '';
				const anchorIndex = Math.floor(
					(word.length - 1) / 2,
				);
				const letters = word.split('');

				let html = '';
				letters.forEach((letter, index) => {
					const isAnchor = index === anchorIndex;
					const anchorClass = isAnchor
						? 'anchor-letter'
						: '';
					const color = isAnchor
						? 'color: var(--highlight-color);'
						: '';
					html += `
						<span
							class="letter ${anchorClass}"
							data-index="${index}"
							style="${color}"
						>${letter}</span>
					`;
				});

				return html;
			}

			function updateWordDisplay() {
				if (wordTokens.length === 0) {
					wordDisplayText.innerHTML = 'Ready';
					return;
				}
				const token = wordTokens[currentIndex];
				const word = token.displayText || token.text;
				wordDisplayText.innerHTML = getAnchorWord(word);
				positionLetters();
				updateTextDisplay();
				updateProgress();
			}

			function updateTextDisplay() {
				if (textDisplay.classList.contains('hidden'))
					return;

				/** @type {NodeListOf<HTMLElement>} */
				const wordSpans = textDisplay.querySelectorAll(
					'.word',
				);

				const currentToken = wordTokens[currentIndex];
				const currentWordIndex = currentToken
					? currentToken.wordIndex
					: -1;

				wordSpans.forEach((span) => {
					const spanWordIndex = parseInt(
						span.dataset.wordIndex ?? '-1',
					);
					span.classList.toggle(
						'current',
						spanWordIndex === currentWordIndex,
					);
				});

				const currentElement = textDisplay
					.querySelector('.word.current');
				if (currentElement) {
					currentElement.scrollIntoView({
						behavior: 'smooth',
						block: 'center',
					});
				}
			}

			function updateProgress() {
				progressLabel.textContent = `Progress: ${
					currentIndex + 1
				} / ${wordTokens.length}`;
				progressSlider.value =
					(wordTokens.length > 0 ? currentIndex : 0)
						.toString();
				progressSlider.max = Math.max(
					wordTokens.length - 1,
					0,
				).toString();
			}

			function startPlayback() {
				if (wordTokens.length === 0)
					return;

				if (currentIndex >= wordTokens.length - 1) {
					currentIndex = 0;
					updateWordDisplay();
				}

				isPlaying = true;
				playPauseBtn.textContent = 'Pause';
				wordDisplay.classList.add('playing');
				schedulePlayNext();
			}

			function schedulePlayNext() {
				const token = wordTokens[currentIndex];
				const delay = getWordTime(
					token.displayText ?? token.text,
				);
				playInterval = setTimeout(playNext, delay);
			}

			function playNext() {
				if (!isPlaying)
					return;

				if (currentIndex < wordTokens.length - 1) {
					currentIndex++;
					schedulePlayNext();
					updateWordDisplay();
				}
				else {
					stopPlayback();
				}
			}

			function stopPlayback() {
				isPlaying = false;
				clearTimeout(playInterval);
				playInterval = undefined;
				playPauseBtn.textContent = 'Play';
				wordDisplay.classList.remove('playing');
			}

			function togglePlayback() {
				if (isPlaying)
					stopPlayback();
				else
					startPlayback();
			}

			function resetPlayback() {
				stopPlayback();
				currentIndex = 0;
				updateWordDisplay();
			}

			function toggleMode() {
				mode = mode == 'edit' ? 'view' : 'edit';

				toggleModeBtn.textContent = mode == 'edit'
					? 'Start'
					: 'Edit';
				playbackFieldset.disabled = mode == 'edit';
				textDisplay.classList.toggle(
					'hidden',
					mode == 'edit',
				);
				textInput.disabled = mode != 'edit';
				textInput.classList.toggle(
					'hidden',
					mode != 'edit',
				);

				if (mode == 'view') {
					text = textInput.value;

					tokens = tokenizeText(text);
					wordTokens = tokens.filter((t) =>
						t.type === 'word'
					);

					textDisplay.innerHTML = '';
					let wordTokenIndex = 0;
					let currentWordIndex = -1;
					/** @type {HTMLSpanElement | null} */
					let currentWordSpan = null;

					tokens.forEach((token) => {
						if (token.type === 'whitespace') {
							const span = document.createElement(
								'span',
							);
							span.textContent = token.text;
							textDisplay.appendChild(span);
							currentWordSpan = null;
						}
						else {
							// Check if this is a new word or part of the previous word
							if (
								token.wordIndex !==
									currentWordIndex
							) {
								// New word - create a new span
								currentWordSpan = document
									.createElement(
										'span',
									);
								currentWordSpan.className =
									'word';
								currentWordSpan.textContent =
									token.text;
								// Store the wordTokens array index for click navigation
								currentWordSpan.dataset
									.wordTokenIndex =
										wordTokenIndex
											.toString();
								// Store the semantic word index for highlighting
								currentWordSpan.dataset
									.wordIndex = token.wordIndex
										.toString();

								const currentIndexValue =
									wordTokenIndex;
								currentWordSpan
									.addEventListener(
										'click',
										() => {
											stopPlayback();
											currentIndex =
												currentIndexValue;
											updateWordDisplay();
										},
									);
								textDisplay.appendChild(
									currentWordSpan,
								);
								currentWordIndex =
									token.wordIndex;
							}
							// Increment wordTokenIndex for EVERY word token (including continuation chunks)
							wordTokenIndex++;

							// For continuation chunks, append to existing span
							if (
								token.wordIndex ===
									currentWordIndex &&
								token.partIndex > 0
							) {
								if (currentWordSpan) {
									currentWordSpan
										.textContent +=
											token.text;
								}
							}
						}
					});

					resetPlayback();
				}
				else {
					stopPlayback();
				}
			}

			async function handlePaste() {
				try {
					const clipboardText = await navigator
						.clipboard.readText();

					if (
						!clipboardText ||
						clipboardText.trim() === ''
					) {
						alert(
							'Clipboard is empty. Please copy some text first.',
						);
						return;
					}

					if (mode == 'view')
						toggleMode();

					textInput.value = clipboardText;

					if (mode == 'edit')
						toggleMode();

					resetPlayback();
					startPlayback();
				}
				catch (error) {
					alert(
						'Failed to read clipboard. Please ensure you have granted clipboard permissions or try pasting manually.',
					);
					console.error('Clipboard error:', error);
				}
			}

			function onSubmitText() {
				if (
					mode == 'edit' &&
					textInput.value.trim() == ''
				) {
					alert('Please enter some text first');
					return;
				}

				toggleMode();
			}

			textInput.addEventListener('keydown', (event) => {
				if (
					(event.ctrlKey || event.metaKey) &&
					event.shiftKey == false &&
					event.altKey == false &&
					event.key === 'Enter'
				) {
					event.preventDefault();
					onSubmitText();
				}
			});

			inputForm.addEventListener('submit', (event) => {
				event.preventDefault();
				onSubmitText();
			});
			playPauseBtn.addEventListener(
				'click',
				togglePlayback,
			);
			resetBtn.addEventListener('click', resetPlayback);

			wpmInput.addEventListener('input', () => {
				let value = parseInt(wpmInput.value) || 200;
				value = Math.max(100, Math.min(500, value));
				wpm = value;
				wpmSlider.value = value.toString();
				if (isPlaying) {
					stopPlayback();
					startPlayback();
				}
			});

			wpmSlider.addEventListener('input', () => {
				wpm = parseInt(wpmSlider.value);
				wpmInput.value = wpm.toString();
				if (isPlaying) {
					stopPlayback();
					startPlayback();
				}
			});

			progressSlider.addEventListener('input', () => {
				const wasPlaying = isPlaying;
				if (isPlaying)
					stopPlayback();
				currentIndex = parseInt(progressSlider.value);
				updateWordDisplay();
			});

			pasteBtn.addEventListener('click', handlePaste);

			document.addEventListener('paste', (event) => {
				if (document.activeElement === textInput)
					return;

				event.preventDefault();
				handlePaste();
			});
		</script>
	</body>
</html>
